IDEAS regarding data type determination.

P1,P2 are pointers
I1,I2 are integers

P1 + P2 = Invalid
P1 - P2 = Integer
P1 * P2 = Invalid
P1 / P2 = Invalid

P1 + I1 = Pointer
P1 - I1 = Pointer
P1 * I1 = Invalid
P1 / I1 = Invalid

I1 + I2 = Integer
I1 - I2 = Integer
I1 * I2 = Integer
I1 / I2 = Integer

+  can be P1 + I1, I1 + I2
-  can be P1 - P2, P1 - I1, I1 - I2
*  can be I1 * I2
/  can be I1 / I2

1) A variable is a pointer if it is used to load/store another variable in memory.
2) Signed/Unsigned integer can be determined from branch statements and other hints.
3) Integer or String can be determined depending on how it is used.
E.g. If it is used as the format variable in a printf() it is a string.
If it is used in the variable args of a printf() statement and the format string identifies it as %s is it a string.


IDEAS and work in progress:
Create a graph for each value or label.
At the top of the graph have the instruction that directly determines the type of a value.
E.g. A STORE or LOAD determines that it is a pointer and what size the value is being stored.
The nodes of the graph are a combined key of value and instruction.

Each value has a list of instructions that use that value.
One of the instructions caused the creation of the SSA value.
The rest of the instructions used the value.

The problem is how to link these value-instruction nodes ?
Investigate a rule that type inferance inherits only from above.
Can you arrange the nodes so this works.

Rules:
1) If one valueA-instruction is a LOAD/STORE so the type is clear, all other valueA-instructions have the same type, so you can raise them to the top of the graph.
2) A sanity check needs to be made so that all valueA-instructions have the same type.
3) Links between nodes are based on instructions. So, an instruction with 3 params will have 1 node at the top, and 2 nodes below it, with links.
But then the next nodes below those will be the previous nodes above them. So, do we then have triangle graph links?
4) If one of the nodes below is a top node, A horizontal or upwards link is used.
5) Also need another link type for different instructions of the same value.
6) Need to work out if order of instructions affects the type?
7) Is this a problem that can be solved with linear programming?
Each value has two properties:
1) Pointer or Int
2) size

Maybe Use a scatter diagram.
Each node is a value-instruction.
Each link between the nodes infers inheritance in the link direction.
Sometimes, an inheritance is inferred only from a combination of more than one node.
So, a new node type is needed, a descision node, which combines more than one link into a single link.
Also, a node that is just the "value" with the links determining the type of the value.

IDEA 3: Type Inference Propagation
Alternatively, create a long list of "if (...) then ..." statements, and then try to solve them.
Need a way to resolve circular statements.

Maybe, If the type is clear, the inheritance should be clear, and thus the value can be removed from the model.
The if (...) then .... can be added and remove from the context depending on whether the params in the (...) are defined type is clear or not.
First pass, selects the ones in context, sorts them to move them to the top of the list. Some of them might have (...) being 1, i.e. always true
Next, the ones selected are executed.
Based on the result, see if any others can be added to the context.
Next, these new ones are executed.
repeat until no new ones can be add to the context.

If when executing the rules, a type is changed, e.g. 32bit goes to 64bit. Then need to modify the instruction stream with bitcasts etc. and re-run the analysis.
If a bitcast is done, retain the bitcast relationship so if a bitcast is needed later on, the same one can be utilised.
If a bitcase is added, the types on all the affected instructions could be reset to unknown, and then the rules can be run again on those instructions
in order to gain type information. This area is difficult because we don't know exactly how to unwide the previous induction steps.
So, we don't know which instructons have been used to make the type inductions, so we will not know if the changed instructions previously contributed to
the type induction.
Adding a bitcase instruction might modify the SSA labeling. A label would be split in 2. The label up until the new bitcast would be the same.
The label after the bitcast would be new.
The reason to add the bitcast instruction is due to the immediately following instruction needing it. So, with this pairing in mind, we can limit the amount
of instructions that might have contributed to the induction.


The final check is to then run all the rules, and verify that they are all valid.
Each rule has several expressions.
One expression to decide to include the rule or not in the context. (e.g. If value1 and value2 defined, and value3 undefined.)
One expression to validate the input data. (e.g. if value1 == ptr and value2 == int)
One expression to update the type data, or use to check the type data. (e.g. value3 == ptr.)
Maybe add negative rules, I.e. for a MUL expression, if either of the values are ptr, abort. or do ptr_to_int casts.


